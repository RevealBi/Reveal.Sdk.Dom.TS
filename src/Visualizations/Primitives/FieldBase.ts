import { JsonProperty } from "../../Core/Serialization/Decorators/JsonProperty";
import { DataType } from "../../Enums/DataType";
import { IFilter } from "../../Filters/Interfaces/IFilter";
import { IField } from "../Interfaces/IField";
import { IFieldDataType } from "../Interfaces/IFieldDataType";

export abstract class FieldBase<TFilter extends IFilter> implements IField, IFieldDataType {
    constructor(fieldName?: string) {
        this.fieldName = fieldName;
        this.fieldLabel = fieldName;
    }

    @JsonProperty("FieldName")
    fieldName?: string;

    @JsonProperty("FieldLabel")
    fieldLabel?: string;

    @JsonProperty("FieldType")
    dataType: DataType = DataType.String; //todo: in .net this is internal. maybe make it a getter only? Do we event need the IFieldDataType interface now?

    @JsonProperty("IsCalculated")
    isCalculated: boolean = false;

    @JsonProperty("Expression")
    expression?: string;

    /**
     * Gets or sets the data filter to apply to the field.
     */
    @JsonProperty("Filter")
    dataFilter?: TFilter; //todo: need a filter converter

    //certain connectors like SalesForce use this - this is generated by Reveal and not currently meant for external use
    @JsonProperty("Properties")
    private properties: Record<string, any> = {}; //todod: not sure this is working properly

    //used when joining data from multiple sources
    @JsonProperty("TableAlias")
    private tableAlias?: string;
}